<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport"
          content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Action Game - Border Fixed</title>

    <style>
        :root {
            --w: 64px;
            --h: 64px;
            --scale: 6;
        }

        body {
            margin: 0;
            background-color: #222;
            display: flex;
            align-items: center;
            justify-content: center;
            height: 100vh;
            overflow: hidden;
            font-family: sans-serif;
        }

        #game-viewport {
            position: relative;
            width: 1280px;
            height: 960px;
            background-color: #aaa;
            overflow: hidden;
            flex-shrink: 0;
            box-shadow: 0 0 40px rgba(0,0,0,0.5);
        }

        #char-container,
        #enemy {
            position: absolute;
            top: 500px;
        }

        #enemy {
            width: var(--w);
            height: var(--h);
            transform: scale(var(--scale));
            image-rendering: pixelated;
            background-image: url('reiya.png');
            background-repeat: no-repeat;
            animation: play-6 0.6s steps(6) infinite;
            transition: filter 0.1s;
        }

        #enemy.face-left {
            background-image: url('reiya_left.png');

        }

#enemy.hit {
    background-image: url('reiya_hit.png') !important;
    /* steps(2) で 0.2秒間隔で2枚をループ再生 */
    animation: play-2 0.2s steps(2) infinite !important;
}

#enemy.face-left.hit {
    background-image: url('reiya_hit_left.png') !important;
    animation: play-2 0.2s steps(2) infinite !important;
}

        #character {
            width: var(--w);
            height: var(--h);
            transform: scale(var(--scale));
            image-rendering: pixelated;
            background-repeat: no-repeat;
            background-size: auto 100%;
        }

        .idle {
            background-image: url('Dark_ma.png');
            animation: play-6 0.6s steps(6) infinite;
        }

        .walk-start {
            background-image: url('Dark_ma_rightstart.png');
            animation: play-2 0.2s steps(2) forwards;
        }

        .walk-loop {
            background-image: url('Dark_ma_right.png');
            animation: play-7 0.7s steps(7) infinite;
        }

        .jump {
            background-image: url('Dark_ma_jump.png');
            animation: play-5 0.5s steps(5) forwards;
        }

        .attack-start {
            background-image: url('Dark_ma_start.png');
            animation: play-4 0.4s steps(4) forwards;
        }

        .attack-loop {
            background-image: url('Dark_ma_loop.png');
            animation: play-5 0.5s steps(5) infinite;
        }

        .attack-end {
            background-image: url('Dark_ma_end.png');
            animation: play-3 0.3s steps(3) forwards;
        }

        .flip {
            transform: scale(var(--scale)) scaleX(-1) !important;
        }

        .hit-effect {
            filter: brightness(10) !important;
        }

        @keyframes play-7 {
            from { background-position: 0 0; }
            to   { background-position: calc(var(--w) * -7) 0; }
        }

        @keyframes play-6 {
            from { background-position: 0 0; }
            to   { background-position: calc(var(--w) * -6) 0; }
        }

        @keyframes play-5 {
            from { background-position: 0 0; }
            to   { background-position: calc(var(--w) * -5) 0; }
        }

        @keyframes play-4 {
            from { background-position: 0 0; }
            to   { background-position: calc(var(--w) * -4) 0; }
        }

        @keyframes play-3 {
            from { background-position: 0 0; }
            to   { background-position: calc(var(--w) * -3) 0; }
        }

        @keyframes play-2 {
            from { background-position: 0 0; }
            to   { background-position: calc(var(--w) * -2) 0; }
        }

        .ui-root {
            position: absolute;
            bottom: 60px;
            width: 100%;
            display: flex;
            justify-content: space-between;
            padding: 0 60px;
            box-sizing: border-box;
        }

        .btn {
            width: 140px;
            height: 140px;
            border-radius: 50%;
            border: none;
            color: white;
            font-size: 3rem;
            font-weight: bold;
            background: #555;
            box-shadow: 0 12px #222;
            user-select: none;
            touch-action: manipulation;
        }

        #btnA {
            background: #e74c3c;
            box-shadow: 0 12px #c0392b;
        }

        #btnB {
            background: #3498db;
            box-shadow: 0 12px #2980b9;
        }

        .btn:active {
            transform: translateY(8px);
            box-shadow: 0 4px rgba(0,0,0,0.5);
        }
    </style>
</head>

<body>
<div id="game-viewport">
    <div id="char-container">
        <div id="character" class="idle"></div>
    </div>

    <div id="enemy"></div>

    <div class="ui-root">
        <div class="d-pad">
            <button id="btnLeft" class="btn">◀︎</button>
            <button id="btnRight" class="btn">▶︎</button>
        </div>

        <div class="actions">
            <button id="btnA" class="btn">A</button>
            <button id="btnB" class="btn">B</button>
        </div>
    </div>
</div>

<script>
// --- 初期設定と変数 ---
const preloadImages = [
    'Dark_ma.png', 'Dark_ma_rightstart.png', 'Dark_ma_right.png',
    'Dark_ma_jump.png', 'Dark_ma_start.png', 'Dark_ma_loop.png',
    'Dark_ma_end.png', 'reiya.png', 'reiya_left.png', 'reiya_hit.png', 'reiya_hit_left.png'
];

let assetsLoaded = false;
Promise.all(preloadImages.map(src => new Promise(resolve => {
    const img = new Image(); img.src = src; img.onload = resolve; img.onerror = resolve;
}))).then(() => { assetsLoaded = true; });

const viewport = document.getElementById('game-viewport');
const container = document.getElementById('char-container');
const char = document.getElementById('character');
const enemy = document.getElementById('enemy');

function setScale() {
    const scale = Math.min(window.innerWidth / 1280, window.innerHeight / 960);
    viewport.style.transform = `scale(${scale})`;
}
window.addEventListener('resize', setScale);
setScale();

let posX = 200, enemyPosX = 1000, velocityX = 0, inputDir = 0, lastInputDir = 0;
let isActing = false, isAttackPressed = false, wasMoving = false;
let hitTimer = null, walkTimer = null, stopTimer = null; // タイマー管理用

// --- 状態管理 (修正) ---
function updateState(state) {
    // 進行中のすべてのタイマーを解除（ここが重要）
    if (walkTimer) { clearTimeout(walkTimer); walkTimer = null; }
    if (stopTimer) { clearTimeout(stopTimer); stopTimer = null; }
    
    char.classList.remove('idle','jump','walk-start','walk-loop','attack-start','attack-loop','attack-end');
    char.classList.add(state);
}

// --- ヒット判定 ---
    function checkHit(isFlipped) {
        const dist = Math.abs(posX - enemyPosX);
        const enemyIsRight = enemyPosX > posX;
        const isFacingEnemy = (enemyIsRight && !isFlipped) || (!enemyIsRight && isFlipped);

        if (dist < 250 && isFacingEnemy) {
            // 1. ヒット中のノックバック（攻撃が当たるたび）
            enemyPosX += (enemyIsRight) ? 35 : -35;
            
            if (enemyIsRight) enemy.classList.add('face-left');
            else enemy.classList.remove('face-left');

            if (!enemy.classList.contains('hit')) {
                enemy.classList.add('hit');
            }

            // 連続ヒット対応のタイマー
            if (hitTimer) clearTimeout(hitTimer);
            
            hitTimer = setTimeout(() => {
                // ★追加：ヒット終了時の「後ろに下がる」演出
                // face-left なら右へ、そうでなければ左へ
                const backstep = enemy.classList.contains('face-left') ? 30 : -30;
                enemyPosX += backstep;

                // 状態解除
                enemy.classList.remove('hit');
                hitTimer = null;
            }, 400); 
        }
    }


// --- 停止アクション (修正) ---
function runStopAction() {
    if (isActing) return;
    isActing = true;
    updateState('attack-end');
    
    // 300ms後に待機に戻る予約
    stopTimer = setTimeout(() => {
        isActing = false;
        stopTimer = null;
        updateState(inputDir !== 0 ? 'walk-start' : 'idle');
    }, 300);
}

// --- メインループ (修正) ---
function update() {
    if (!assetsLoaded) { requestAnimationFrame(update); return; }

    // ★割り込み処理：停止モーション中に移動入力があったら強制キャンセル
    if (isActing && char.classList.contains('attack-end') && inputDir !== 0) {
        isActing = false;
        if (stopTimer) { clearTimeout(stopTimer); stopTimer = null; }
        updateState('walk-start');
    }

    const canMove = !isActing || char.classList.contains('jump');
    if (canMove) {
        if (inputDir !== 0) {
            // 切り返し時のアニメーション強制更新
            if (inputDir !== lastInputDir && !char.classList.contains('jump')) {
                updateState('walk-start');
                walkTimer = setTimeout(() => {
                    if (!isActing && inputDir !== 0) updateState('walk-loop');
                }, 200);
            }
            velocityX += inputDir * 1.5;
            char.classList.toggle('flip', inputDir === -1);
        } else {
            velocityX *= 0.7;
        }
    }
    lastInputDir = inputDir;
    velocityX *= 0.9;
    posX += velocityX;

    const isMovingNow = Math.abs(velocityX) > 1;
    // 入力が止まっている時だけ停止アクションへ
    if (wasMoving && !isMovingNow && !isActing && inputDir === 0 && !char.classList.contains('jump')) {
        runStopAction();
    }
    wasMoving = isMovingNow;

    // 見切れ防止
    const margin = 128;
    if (posX < margin) posX = margin;
    if (posX > 1280 - margin) posX = 1280 - margin;
    if (enemyPosX < margin) enemyPosX = margin;
    if (enemyPosX > 1280 - margin) enemyPosX = 1280 - margin;

    container.style.left = posX + 'px';
    enemy.style.left = enemyPosX + 'px';

    if (!isActing) {
        const speed = Math.abs(velocityX);
        if (!char.classList.contains('jump')) {
            if (speed > 1) {
                if (!char.classList.contains('walk-start') && !char.classList.contains('walk-loop')) {
                    updateState('walk-start');
                    walkTimer = setTimeout(() => {
                        if (!isActing && inputDir !== 0) updateState('walk-loop');
                    }, 200);
                }
            } else {
                if (!char.classList.contains('idle')) updateState('idle');
            }
        }
    }
    requestAnimationFrame(update);
}
update();

// --- アクション関連 ---
async function runAttack() {
    if (isActing) return;
    isActing = true;
    const isFlipped = char.classList.contains('flip');
    const isMoving = Math.abs(velocityX) > 1;

    if (!isMoving) {
        updateState('attack-start');
        await new Promise(r => setTimeout(r, 400));
    }

    posX += isFlipped ? -40 : 40;
    updateState('attack-loop');
    checkHit(isFlipped);

    let loopCount = 0;
    while (isAttackPressed || loopCount < 1) {
        await new Promise(r => setTimeout(r, 300));
        loopCount++;
        if (isAttackPressed) checkHit(isFlipped);
    }

    updateState('attack-end');
    await new Promise(r => setTimeout(r, 300));
    isActing = false;
    updateState(inputDir !== 0 ? 'walk-loop' : 'idle');
}

async function runJump() {
    if (isActing) return;
    isActing = true;
    updateState('jump');
    await new Promise(r => setTimeout(r, 500));
    isActing = false;
    updateState(inputDir !== 0 ? 'walk-start' : 'idle');
}

const setupBtn = (id, down, up) => {
    const el = document.getElementById(id);
    const start = e => { e.preventDefault(); down(); };
    const stop  = e => { e.preventDefault(); up(); };
    el.addEventListener('touchstart', start); el.addEventListener('mousedown', start);
    el.addEventListener('touchend', stop); el.addEventListener('mouseup', stop);
};

setupBtn('btnLeft',  () => inputDir = -1, () => inputDir = 0);
setupBtn('btnRight', () => inputDir = 1,  () => inputDir = 0);
setupBtn('btnA', () => { isAttackPressed = true; runAttack(); }, () => isAttackPressed = false);
document.getElementById('btnB').addEventListener('touchstart', e => { e.preventDefault(); runJump(); });
document.getElementById('btnB').addEventListener('mousedown', e => { e.preventDefault(); runJump(); });
</script>
</body>
</html>
